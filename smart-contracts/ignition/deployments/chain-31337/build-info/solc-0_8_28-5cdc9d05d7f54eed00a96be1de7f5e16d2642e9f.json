{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5cdc9d05d7f54eed00a96be1de7f5e16d2642e9f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ArcanePact.sol": "project/contracts/ArcanePact.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ArcanePact.sol": {
        "content": "// Author: Manzai-1\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n\npragma solidity 0.8.28;\n\ncontract ArcanePact {\n    uint256 private nextId;\n    bool private locked;\n\n    enum CampaignState {\n        Initialized,\n        Running,\n        Completed\n    }\n    enum PlayerState {\n        None,\n        Applied,\n        Rejected,\n        AwaitingSignature,\n        Signed\n    }\n    enum ApplicationDecision {\n        Approved,\n        Rejected\n    }\n    enum VoteType {\n        StartCampaign,\n        StopCampaign\n    }\n    enum ReviewScore {\n        Positive,\n        Negative\n    }\n\n    struct Player {\n        PlayerState state;\n        uint256 lockedCollateral;\n    }\n    struct Campaign {\n        address owner;\n        CampaignState state;\n        bool inviteOnly;\n        uint256 collateral;\n        uint256 gamemasterFee;\n        uint256 lockedFees;\n        uint256 participantCount;\n    }\n    struct NewCampaignConfig {\n        string title;\n        string description;\n        bool inviteOnly;\n        uint256 gamemasterFee;\n        uint256 collateral;\n    }\n    struct Review {\n        ReviewScore score;\n        string comment;\n    }\n\n    event CampaignCreated(\n        uint256 indexed campaignId, \n        address indexed owner, \n        CampaignState indexed campaignState, \n        uint256 participantCount,\n        uint256 lockedFees,\n        NewCampaignConfig config\n    );\n    \n    event UpdatedCampaignPlayer(\n        uint256 indexed campaignId,\n        address indexed player,\n        PlayerState indexed playerState\n    );\n\n    event CampaignParticipantCountChanged(\n        uint256 indexed campaignId,\n        uint256 participantCount\n    );\n\n    event PlayerLockedCollateral(\n        uint256 indexed campaignId,\n        address indexed player,\n        uint256 collateral\n    );\n\n    event UpdatedLockedFees(\n        uint256 indexed campaignId,\n        uint256 totalLockedFees\n    );\n\n    event NewVoteAdded(\n        uint256 indexed campaignId,\n        VoteType voteType,\n        address player\n    );\n\n    // not added to subgraph.yaml yet\n    event UpdatedCampaignState(\n        uint256 indexed campaignId,\n        CampaignState campaignState\n    );\n\n    event LockedFeesWithdrawn(\n        uint256 indexed campaignId,\n        uint256 withdrawnAmount,\n        uint256 currentlyLockedAmount\n    );\n\n    event LockedCollateralWithdrawn(\n        uint256 indexed campaignId,\n        uint256 withdrawnAmount,\n        uint256 currentlyLockedAmount\n    );\n\n    event ReviewAdded(\n        uint256 indexed campaignId,\n        address indexed recipient,\n        address indexed sender,\n        Review review\n    );\n\n    error FunctionNotFound();\n    error PaymentDataMissing();\n    error NotOwner(address caller);\n    error CampaignLocked(uint256 campaignId);\n    error CampaignDoesNotExist(uint256 campaignId);\n    error PlayerExistsInCampaign(uint256 campaignId, address player);\n    error CampaignIsInviteOnly(uint256 campaignId);\n    error ApplicantDoesNotExist(uint256 campaignId, address applicant);\n    error ApplicantAlreadyRejected(uint256 campaignId, address applicant);\n    error ApplicantAlreadyApproved(uint256 campaignId, address applicant);\n    error PlayerNotAwaitingSignature(uint256 campaignId, address player);\n    error PlayerHasNotSigned(uint256 campaignId, address player);\n    error IncorrectTransactionValue(uint256 gamemasterFee, uint256 collateral, uint256 received);\n    error HasAlreadyVoted(uint256 campaignId, address player, VoteType voteType);\n    error CampaignNotCompleted(uint256 campaignId);\n    error HasNoLockedFees(uint256 campaignId);\n    error BlockedDueToReEntrancy(uint256 campaignId, address caller);\n    error TransferFailed(uint256 amount, address recipient);\n    error HasNoLockedCollateral(uint256 campaignId, address player);\n    error AlreadyReviewed(uint256 campaignId, address receiver, address caller);\n    error CannotReviewSelf();\n\n    mapping(uint256 => Campaign) internal campaigns;\n    mapping(uint256 => mapping(address => Player)) internal campaignPlayers;\n    mapping(uint256 => mapping(VoteType => uint256)) internal campaignVoteCount; \n    mapping(uint256 => mapping(VoteType => mapping(address => bool))) internal campaignHasVoted;\n    mapping(uint256 => mapping(address => mapping(address => bool))) internal playerHasReviewed;\n\n    constructor () {\n        nextId = 1;\n    }\n\n    fallback() external payable {\n        revert FunctionNotFound();\n    }\n\n    receive() external payable {\n        revert PaymentDataMissing();\n    }\n\n    function newCampaign (NewCampaignConfig calldata config) external{\n        uint256 campaignId = nextId++;\n        Campaign storage campaign = campaigns[campaignId];\n        \n        campaign.owner = msg.sender;\n        campaign.state = CampaignState.Initialized;\n        campaign.inviteOnly = config.inviteOnly;\n        campaign.collateral = config.collateral;\n        campaign.gamemasterFee = config.gamemasterFee;\n        campaign.lockedFees = 0;\n        campaign.participantCount = 1;\n\n        emit CampaignCreated(campaignId, msg.sender, campaign.state, campaign.participantCount, campaign.lockedFees,config);\n    }\n\n    function invitePlayers (uint256 campaignId, address[] calldata addresses) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId); \n        checkIsOwner(campaign.owner, msg.sender);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        for(uint256 i = 0; i < addresses.length; i++) {\n            address adr = addresses[i];\n            Player storage player = campaignPlayers[campaignId][adr];\n\n            checkPlayerAlreadyInCampaign(player.state, campaignId, adr);\n\n            player.state = PlayerState.AwaitingSignature;\n            emit UpdatedCampaignPlayer(campaignId, adr, player.state);\n        }\n    }\n\n    function campaignApplication (uint256 campaignId) external {\n        address applicant = msg.sender;\n\n        Campaign storage campaign = campaigns[campaignId];\n        checkCampaignExists(campaign.owner, campaignId); \n        checkCampaignInviteOnly(campaign.inviteOnly, campaignId);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        Player storage player = campaignPlayers[campaignId][applicant];\n        checkPlayerAlreadyInCampaign(player.state, campaignId, applicant);\n        \n        player.state = PlayerState.Applied;\n        emit UpdatedCampaignPlayer(campaignId, applicant, player.state);\n    }\n\n    function reviewApplication(uint256 campaignId, address applicant, ApplicationDecision decision) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId); \n        checkIsOwner(campaign.owner, msg.sender);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        Player storage player = campaignPlayers[campaignId][applicant];\n        checkApplicantExists(player.state, campaignId, applicant); \n\n        if(decision == ApplicationDecision.Approved) {\n            player.state = PlayerState.AwaitingSignature;\n        } else {\n            player.state = PlayerState.Rejected;\n        }\n\n        emit UpdatedCampaignPlayer(campaignId, applicant, player.state);\n    }\n\n    function signCampaign(uint256 campaignId) external payable {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        Player storage player = campaignPlayers[campaignId][msg.sender];\n        checkPlayerAwaitingSignature(player.state, campaignId, msg.sender);\n\n        uint256 collateral = campaign.collateral;\n        uint256 gamemasterFee = campaign.gamemasterFee;\n        checkTransactionValue(gamemasterFee, collateral, msg.value);\n\n        campaign.lockedFees += campaign.gamemasterFee;\n        player.lockedCollateral += campaign.collateral;\n        player.state = PlayerState.Signed;\n\n        campaign.participantCount += 1;\n\n        emit UpdatedCampaignPlayer(campaignId, msg.sender, player.state);\n        emit CampaignParticipantCountChanged(campaignId, campaign.participantCount);\n        emit PlayerLockedCollateral(campaignId, msg.sender, collateral);\n        emit UpdatedLockedFees(campaignId, campaign.lockedFees);\n    }\n\n    //can be optimized with bit shifting / bitmasks\n    function addVote(uint256 campaignId, VoteType voteType) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId);\n        checkCampaignNotCompleted(campaign.state, campaignId);\n\n        if(campaign.owner != msg.sender){\n            Player storage player = campaignPlayers[campaignId][msg.sender];\n            checkPlayerSigned(player.state, campaignId, msg.sender);\n        }\n\n        if(campaignHasVoted[campaignId][voteType][msg.sender]){\n            revert HasAlreadyVoted(campaignId, msg.sender, voteType);\n        }\n\n        campaignVoteCount[campaignId][voteType] += 1;\n        campaignHasVoted[campaignId][voteType][msg.sender] = true;\n\n        emit NewVoteAdded(campaignId, voteType, msg.sender);\n\n        if(campaignVoteCount[campaignId][voteType] > (campaign.participantCount / 2)){\n            if(voteType == VoteType.StartCampaign){\n                campaign.state = CampaignState.Running;\n                emit UpdatedCampaignState(campaignId, campaign.state);\n            }\n\n            if(voteType == VoteType.StopCampaign){\n                campaign.state = CampaignState.Completed;\n                emit UpdatedCampaignState(campaignId, campaign.state);\n            }\n        }\n    }\n\n    function withdrawFees(uint256 campaignId) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId);\n        checkIsOwner(campaign.owner, msg.sender);\n        checkIfCampaignCompleted(campaign.state, campaignId);\n        checkHasLockedFees(campaign.lockedFees, campaignId);\n\n        if(locked) revert BlockedDueToReEntrancy(campaignId, msg.sender);\n        locked = true;\n\n        uint256 amountToTransfer = campaign.lockedFees;\n        campaign.lockedFees = 0;\n        transferFunds(amountToTransfer, msg.sender);\n\n        locked = false;\n\n        emit LockedFeesWithdrawn(campaignId, amountToTransfer, campaign.lockedFees);\n    }\n\n    function withdrawCollateral(uint256 campaignId) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId);\n        checkIfCampaignCompleted(campaign.state, campaignId);\n\n        Player storage player = campaignPlayers[campaignId][msg.sender];\n        checkPlayerSigned(player.state, campaignId, msg.sender);\n        checkHasLockedCollateral(player.lockedCollateral, campaignId, msg.sender);\n\n        if(locked) revert BlockedDueToReEntrancy(campaignId, msg.sender);\n        locked = true;\n\n        uint256 amountToTransfer = player.lockedCollateral;\n        player.lockedCollateral = 0;\n        transferFunds(amountToTransfer, msg.sender);\n\n        locked = false;\n\n        emit LockedCollateralWithdrawn(campaignId, amountToTransfer, player.lockedCollateral);\n    }\n\n    function addReview(uint256 campaignId, address recipient, Review calldata review) external {\n        if(recipient == msg.sender) revert CannotReviewSelf();\n\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId);\n        checkIfCampaignCompleted(campaign.state, campaignId);\n\n\n        if(campaign.owner != msg.sender){\n            Player storage player = campaignPlayers[campaignId][msg.sender];\n            checkPlayerSigned(player.state, campaignId, msg.sender);\n        }\n\n        if(campaign.owner != recipient){\n            Player storage player = campaignPlayers[campaignId][recipient];\n            checkPlayerSigned(player.state, campaignId, msg.sender);\n        }\n\n        checkAlreadyReviewed(\n            playerHasReviewed[campaignId][msg.sender][recipient], \n            campaignId,\n            recipient,\n            msg.sender\n        );\n\n        playerHasReviewed[campaignId][msg.sender][recipient] = true;\n\n        emit ReviewAdded(campaignId, recipient, msg.sender, review);\n    }\n\n    function transferFunds(uint256 amount, address recipient) private {\n        (bool ok, ) = payable(recipient).call{value: amount}(\"\");\n        if(!ok) revert TransferFailed(amount, recipient);\n    }\n\n    function checkIsOwner(address owner, address sender) internal pure {\n        if(owner != sender) revert NotOwner(sender);\n    }\n\n    function checkCampaignExists(address owner, uint256 campaignId) internal pure {\n        if(owner == address(0)) revert CampaignDoesNotExist(campaignId);\n    }\n\n    function checkApplicantExists(PlayerState state, uint256 campaignId, address applicant) internal pure {\n        if(state != PlayerState.Applied) revert ApplicantDoesNotExist(campaignId, applicant);\n    }\n\n    function checkApplicantAlreadyApproved(PlayerState state, uint256 campaignId, address applicant) internal pure {\n        if(state == PlayerState.AwaitingSignature) revert ApplicantAlreadyApproved(campaignId, applicant);\n    }\n\n    function checkApplicantAlreadyRejected(PlayerState state, uint256 campaignId, address applicant) internal pure {\n        if(state == PlayerState.Rejected) revert ApplicantAlreadyRejected(campaignId, applicant);\n    }\n\n    function checkCampaignInviteOnly(bool inviteOnly, uint256 campaignId) internal pure {\n        if(inviteOnly) revert CampaignIsInviteOnly(campaignId);\n    }\n\n    function checkPlayerAlreadyInCampaign(PlayerState state, uint256 campaignId, address player) internal pure {\n        if(state != PlayerState.None) revert PlayerExistsInCampaign(campaignId, player);\n    }\n\n    function checkPlayerAwaitingSignature(PlayerState state, uint256 campaignId, address player) internal pure {\n        if(state != PlayerState.AwaitingSignature) revert PlayerNotAwaitingSignature(campaignId, player);\n    }\n\n    function checkPlayerSigned(PlayerState state, uint256 campaignId, address player) internal pure {\n        if(state != PlayerState.Signed) revert PlayerHasNotSigned(campaignId, player);\n    }\n\n    function checkIfCampaignLocked(CampaignState state, uint256 campaignId) internal pure {\n        if(state != CampaignState.Initialized) revert CampaignLocked(campaignId);\n    }\n\n    function checkCampaignNotCompleted(CampaignState state, uint256 campaignId) internal pure {\n        if(state == CampaignState.Completed) revert CampaignLocked(campaignId);\n    }\n\n    function checkIfCampaignCompleted(CampaignState state, uint256 campaignId) internal pure {\n        if(state != CampaignState.Completed) revert CampaignNotCompleted(campaignId);\n    }\n\n    function checkTransactionValue(uint256 fee, uint256 collateral, uint256 received) internal pure {\n        if(received != (fee + collateral)) revert IncorrectTransactionValue(fee, collateral, received);\n    }\n\n    function checkAlreadyVoted(bool hasVoted, uint256 campaignId, address player, VoteType voteType) internal pure {\n        if(hasVoted) revert HasAlreadyVoted(campaignId, player, voteType);\n    }\n\n    function checkHasLockedFees(uint256 lockedFees, uint256 campaignId) internal pure {\n        if(!(lockedFees > 0)) revert HasNoLockedFees(campaignId);\n    }\n\n    function checkHasLockedCollateral(uint256 lockedColalteral, uint256 campaignId, address player) internal pure {\n        if(!(lockedColalteral > 0)) revert HasNoLockedCollateral(campaignId, player);\n    }\n\n    function checkAlreadyReviewed(bool hasReviewed, uint256 campaignId, address recipient, address caller) internal pure {\n        if(hasReviewed) revert AlreadyReviewed(campaignId, recipient, caller);\n    }\n}"
      }
    }
  }
}