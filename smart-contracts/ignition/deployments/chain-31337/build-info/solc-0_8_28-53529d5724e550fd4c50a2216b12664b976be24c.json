{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-53529d5724e550fd4c50a2216b12664b976be24c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ArcanePact.sol": "project/contracts/ArcanePact.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ArcanePact.sol": {
        "content": "// Author: Manzai-1\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n\npragma solidity 0.8.28;\n\ncontract ArcanePact {\n    uint256 private nextId;\n\n\n    enum CampaignState {\n        Initialized,\n        Running,\n        Completed\n    }\n    enum PlayerState {\n        None,\n        Applied,\n        Rejected,\n        AwaitingSignature,\n        Signed,\n        InSession\n    }\n    enum ApplicationDecision {\n        Approved,\n        Rejected\n    }\n\n    struct ApplicationReview {\n        address applicant;\n        ApplicationDecision decision;\n    }\n    struct Player {\n        PlayerState state;\n    }\n    struct Campaign {\n        address owner;\n        CampaignState state;\n        bool inviteOnly;\n    }\n    struct NewCampaignConfig {\n        string title;\n        string description;\n        bool inviteOnly;\n        uint256 gamemasterFee;\n        uint256 collateral;\n    }\n    \n    mapping(uint256 => Campaign) internal campaigns;\n    mapping(uint256 => mapping(address => Player)) internal campaignPlayers;\n\n    event CampaignCreated(\n        uint256 indexed campaignId, \n        address indexed owner, \n        NewCampaignConfig config\n    );\n    event ApplicationAdded(\n        uint256 indexed campaignId,\n        address indexed player\n    );\n    event ApplicationAproved(\n        uint256 indexed campaignId,\n        address indexed player\n    );\n    event ApplicationRejected(\n        uint256 indexed campaignId,\n        address indexed player\n    );\n    event InvitationAdded(\n        uint256 indexed campaignId,\n        address player\n    );\n\n    error NotOwner(address caller);\n    error CampaignLocked(uint256 campaignId);\n    error CampaignDoesNotExist(uint256 campaignId);\n    error PlayerExistsInCampaign(uint256 campaignId, address player);\n    error CampaignIsInviteOnly(uint256 campaignId);\n    error ApplicantDoesNotExist(uint256 campaignId, address applicant);\n    error ApplicantAlreadyRejected(uint256 campaignId, address applicant);\n    error ApplicantAlreadyApproved(uint256 campaignId, address applicant);\n\n\n    constructor () {\n        nextId = 1;\n    }\n\n    function newCampaign (NewCampaignConfig calldata config) external{\n        uint256 campaignId = nextId++;\n        Campaign storage campaign = campaigns[campaignId];\n        \n        campaign.owner = msg.sender;\n        campaign.state = CampaignState.Initialized;\n        campaign.inviteOnly = config.inviteOnly;\n\n        emit CampaignCreated(campaignId, msg.sender, config);\n    }\n\n    function invitePlayers (uint256 campaignId, address[] calldata addresses) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId); \n        checkIsOwner(campaign.owner, msg.sender);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        for(uint256 i = 0; i < addresses.length; i++) {\n            address adr = addresses[i];\n            Player storage player = campaignPlayers[campaignId][adr];\n\n            checkPlayerAlreadyInCampaign(player.state, campaignId, adr);\n\n            player.state = PlayerState.AwaitingSignature;\n            emit InvitationAdded(campaignId, adr);\n        }\n    }\n\n    function campaignApplication (uint256 campaignId) external {\n        address applicant = msg.sender;\n\n        Campaign storage campaign = campaigns[campaignId];\n        checkCampaignExists(campaign.owner, campaignId); \n        checkCampaignInviteOnly(campaign.inviteOnly, campaignId);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        Player storage player = campaignPlayers[campaignId][applicant];\n        checkPlayerAlreadyInCampaign(player.state, campaignId, applicant);\n        \n        player.state = PlayerState.Applied;\n        emit ApplicationAdded(campaignId, applicant);\n    }\n\n    function ReviewApplications(uint256 campaignId, ApplicationReview[] calldata reviews) external {\n        Campaign storage campaign = campaigns[campaignId];\n\n        checkCampaignExists(campaign.owner, campaignId); \n        checkIsOwner(campaign.owner, msg.sender);\n        checkIfCampaignLocked(campaign.state, campaignId);\n\n        for(uint256 i = 0; i < reviews.length; i++){\n            ApplicationDecision decision = reviews[i].decision;\n            address applicant = reviews[i].applicant;\n\n            Player storage player = campaignPlayers[campaignId][applicant];\n\n            checkApplicantExists(player.state, campaignId, applicant); \n        \n            if(decision == ApplicationDecision.Approved){\n                checkApplicantAlreadyApproved(player.state, campaignId, applicant);\n                player.state = PlayerState.AwaitingSignature;\n                emit ApplicationAproved(campaignId, applicant);\n            } else {\n                checkApplicantAlreadyRejected(player.state, campaignId, applicant);\n                player.state = PlayerState.Rejected;\n                emit ApplicationRejected(campaignId, applicant);\n            }\n        }\n    }\n\n\n\n    function checkIsOwner(address owner, address sender) internal pure {\n        if(owner != sender) revert NotOwner(sender);\n    }\n\n    function checkCampaignExists(address owner, uint256 campaignId) internal pure {\n        if(owner == address(0)) revert CampaignDoesNotExist(campaignId);\n    }\n\n    function checkApplicantExists(PlayerState state, uint256 campaignId, address applicant) internal pure {\n        if(state == PlayerState.None) revert ApplicantDoesNotExist(campaignId, applicant);\n    }\n\n    function checkApplicantAlreadyApproved(PlayerState state, uint256 campaignId, address applicant) internal pure {\n        if(state == PlayerState.AwaitingSignature) revert ApplicantAlreadyApproved(campaignId, applicant);\n    }\n\n    function checkApplicantAlreadyRejected(PlayerState state, uint256 campaignId, address applicant) internal pure {\n        if(state == PlayerState.Rejected) revert ApplicantAlreadyRejected(campaignId, applicant);\n    }\n\n    function checkCampaignInviteOnly(bool inviteOnly, uint256 campaignId) internal pure {\n        if(inviteOnly) revert CampaignIsInviteOnly(campaignId);\n    }\n\n    function checkPlayerAlreadyInCampaign(PlayerState state, uint256 campaignId, address player) internal pure {\n        if(state != PlayerState.None) revert PlayerExistsInCampaign(campaignId, player);\n    }\n\n    function checkIfCampaignLocked(CampaignState state, uint256 campaignId) internal pure {\n        if(state != CampaignState.Initialized) revert CampaignLocked(campaignId);\n    }\n}"
      }
    }
  }
}